diff -rupN a/arch/mips/ath79/dev-wmac.c b/arch/mips/ath79/dev-wmac.c
--- a/arch/mips/ath79/dev-wmac.c
+++ b/arch/mips/ath79/dev-wmac.c
@@ -20,6 +20,14 @@
 #include <linux/ath9k_platform.h>
 #include <linux/gpio.h>
 
+#include <linux/types.h>
+
+#include <linux/mtd/mtd.h>
+
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/of_net.h>
+
 #include <asm/mach-ath79/ath79.h>
 #include <asm/mach-ath79/ar71xx_regs.h>
 #include "common.h"
@@ -462,3 +470,78 @@ void __init ath79_register_wmac_simple(v
 	ath79_register_wmac(NULL, NULL);
 	ath79_wmac_data.eeprom_name = "soc_wmac.eeprom";
 }
+
+
+static int ath79_wmac_probe(struct platform_device *_pdev)
+{
+	struct device_node *mtd_np = NULL;
+	size_t retlen;
+	int size, ret;
+	struct mtd_info *mtd;
+	const char *part;
+	const __be32 *list;
+	phandle phandle;
+
+	const char* mac_addr;
+
+	list = of_get_property(_pdev->dev.of_node, "mtd-eeprom", &size);
+	if (!list || (size != (2 * sizeof(*list)))) {
+		return -0; // which error should be returned here?;
+	}
+
+	phandle = be32_to_cpup(list++);
+	if (phandle)
+		mtd_np = of_find_node_by_phandle(phandle);
+
+	if (!mtd_np) {
+		return 0; // or -EPROBE_DEFER ?
+	}
+
+	part = of_get_property(mtd_np, "label", NULL);
+	if (!part)
+		part = mtd_np->name;
+
+	mtd = get_mtd_device_nm(part);
+	if (IS_ERR(mtd)) {
+		// flash / mtd partition for EEPROM / ART is not present yet,
+		// try again later
+		return -EPROBE_DEFER;
+	}
+
+	ret = mtd_read(mtd, be32_to_cpup(list), sizeof(ath79_wmac_data.eeprom_data), &retlen, (unsigned char *) ath79_wmac_data.eeprom_data);
+	put_mtd_device(mtd);
+
+	mac_addr = of_get_mac_address(_pdev->dev.of_node);
+	if (mac_addr) {
+		ether_addr_copy(ath79_wmac_mac, mac_addr);
+		ath79_wmac_data.macaddr = ath79_wmac_mac;
+	}
+
+	if (!is_valid_ether_addr(ath79_wmac_data.macaddr)) {
+		// flash / mtd partition for MAC address is not present yet,
+		// try again later
+		return -EPROBE_DEFER;
+	}
+
+	ath79_register_wmac(NULL, NULL);
+
+	return 0;
+}
+
+static const struct of_device_id ath79_wmac_of_match[] = {
+	{ .compatible = "ath79,wmac" },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(of, ath79_wmac_of_match);
+
+static struct platform_driver ath79_wmac_driver = {
+	.probe  = ath79_wmac_probe,
+	.driver = {
+		.name = "ath79-wmac",
+		.of_match_table = of_match_ptr(ath79_wmac_of_match),
+	}
+};
+
+
+module_platform_driver(ath79_wmac_driver);
